//@version=5
//Â©InSilico
//Extension/Mod for - https://www.tradingview.com/script/2rZDPyaC-Leledc-Exhaustion-Bar/ 
indicator(title='Exhaustion levels (InSilico)', shorttitle='LeveLeledc (InSilico)', overlay=true)

//Input
exhaustionSwitch = input(true, title='Show exhaustion Bar point (Arrows)')
levelSwitch = input(true, title='Show exhaustion levels (Lines)')
initial_length = input.int(40, 'Initial Exhaustions Swing Length') // Renamed from length
initial_bars = input.int(10, 'Initial Exhaustion Bar Count')     // Renamed from bars
thicknesSwitch = input(2, title='Line Thickness(Level thickness)')

// --- Reinforcement Learning Inputs ---
enable_rl = input.bool(true, title='Enable Reinforcement Learning', group='Reinforcement Learning')
n_lookahead_pivot = input.int(10, title='Pivot Lookahead Bars', tooltip='How many bars to look ahead to confirm a pivot for reward calculation', group='Reinforcement Learning', minval=1)
param_update_frequency = input.int(50, title='Parameter Update Frequency', tooltip='How often (in bars) to evaluate and potentially update parameters', group='Reinforcement Learning', minval=10)
learning_rate = input.float(0.1, title='Learning Rate', tooltip='Rate at which new rewards update parameter scores (0.0 to 1.0)', group='Reinforcement Learning', minval=0.0, maxval=1.0, step=0.01)
exploration_chance = input.float(0.2, title='Exploration Chance', tooltip='Chance to explore random parameter changes (0.0 to 1.0)', group='Reinforcement Learning', minval=0.0, maxval=1.0, step=0.01)
length_min = input.int(10, title='Min Swing Length', group='Reinforcement Learning', minval=1)
length_max = input.int(200, title='Max Swing Length', group='Reinforcement Learning', minval=1)
length_step = input.int(5, title='Swing Length Step', group='Reinforcement Learning', minval=1)
bars_min = input.int(3, title='Min Exhaustion Bars', group='Reinforcement Learning', minval=1)
bars_max = input.int(30, title='Max Exhaustion Bars', group='Reinforcement Learning', minval=1)
bars_step = input.int(1, title='Exhaustion Bars Step', group='Reinforcement Learning', minval=1)
min_samples_for_decision = input.int(10, title='Min Samples for Decision', tooltip='Min signals evaluated before switching to new candidate parameters', group='Reinforcement Learning', minval=1)
show_rl_debug_info = input.bool(false, title='Show RL Debug Info', group='Reinforcement Learning')

// --- RL State Variables ---
var float learned_length = float(initial_length) // Ensure it's float for calculations
var float learned_bars = float(initial_bars)     // Ensure it's float for calculations
var float candidate_length = float(initial_length)
var float candidate_bars = float(initial_bars)
var float current_params_score = 0.0
var float candidate_params_score = 0.0
var int score_samples_current = 0
var int score_samples_candidate = 0
var int last_param_update_eval_bar = 0
var array<int> signal_bar_indices = array.new_int()
var array<int> signal_types = array.new_int() // 1 for buy low (lowlel), -1 for sell high (highlel)
var array<float> signal_prices = array.new_float()

//Fun Lele
Lelec(bars, len) => // Note: The original script had 'length' and 'bars' here. This will be addressed in a later step. For now, only inputs are modified.
    bindex = int(na)
    bindex := nz(bindex[1], 0)
    sindex = int(na)
    sindex := nz(sindex[1], 0)
    return_1 = 0
    bindex := close > close[4] ? bindex + 1 : bindex
    sindex := close < close[4] ? sindex + 1 : sindex
    if bindex > bars and close < open and high >= ta.highest(high, len)
        bindex := 0
        return_1 := -1
        return_1
    else
        if sindex > bars and close > open and low <= ta.lowest(low, len)
            sindex := 0
            return_1 := 1
            return_1

// Lelex calculation now uses candidate parameters if RL is enabled, otherwise initial static parameters.
// Parameters passed to Lelec are explicitly cast to int where necessary.
Lelex = Lelec(enable_rl ? int(candidate_bars) : initial_bars, enable_rl ? int(candidate_length) : initial_length)

// --- RL: Signal Tracking for Candidate Parameters ---
int MAX_SIGNAL_ARRAY_SIZE = 50 // Define a max size for the signal tracking arrays

if enable_rl and Lelex != 0
    // Add new signal
    array.push(signal_bar_indices, bar_index)
    array.push(signal_types, Lelex)
    array.push(signal_prices, Lelex == -1 ? high : low)

    // Ensure arrays do not exceed max size
    if array.size(signal_bar_indices) > MAX_SIGNAL_ARRAY_SIZE
        array.shift(signal_bar_indices)
        array.shift(signal_types)
        array.shift(signal_prices)

// --- RL: Reward Calculation and Score Update ---
if enable_rl
    if array.size(signal_bar_indices) > 0
        s_bar_idx = array.get(signal_bar_indices, 0)
        s_type = array.get(signal_types, 0)
        s_price = array.get(signal_prices, 0)

        // Check if the signal is mature enough to evaluate
        if bar_index >= s_bar_idx + n_lookahead_pivot
            is_true_pivot = true
            // s_price is the high/low of the bar where the signal occurred (s_bar_idx)
            // We are checking the window from s_bar_idx to s_bar_idx + n_lookahead_pivot - 1.
            // For a sell signal (s_type == -1), s_price was high[s_bar_idx].
            // We check if any bar in the lookahead window had a high STRICTLY GREATER than s_price.
            // For a buy signal (s_type == 1), s_price was low[s_bar_idx].
            // We check if any bar in the lookahead window had a low STRICTLY LOWER than s_price.

            if s_type == -1 // Sell signal (High pivot)
                for i = 0 to n_lookahead_pivot - 1
                    // bar_offset is the lookback period from the current bar to s_bar_idx + i
                    bar_offset = bar_index - (s_bar_idx + i)
                    // Ensure the offset is valid (not future data, not too far past if history is limited, though Pine handles na)
                    if bar_offset >= 0 // and bar_offset < bar_index (implicit for historical data access)
                        if high[bar_offset] > s_price
                            is_true_pivot := false
                            break
            else if s_type == 1 // Buy signal (Low pivot)
                for i = 0 to n_lookahead_pivot - 1
                    bar_offset = bar_index - (s_bar_idx + i)
                    if bar_offset >= 0
                        if low[bar_offset] < s_price
                            is_true_pivot := false
                            break
            
            reward = is_true_pivot ? 1.0 : -1.0

            // Update candidate score using EMA-like approach
            if score_samples_candidate == 0
                candidate_params_score := reward
            else
                candidate_params_score := candidate_params_score * (1 - learning_rate) + reward * learning_rate
            
            score_samples_candidate += 1

            // Remove the processed signal from the front of the arrays
            array.shift(signal_bar_indices)
            array.shift(signal_types)
            array.shift(signal_prices)

// --- RL: Parameter Evaluation and Update ---
if enable_rl and bar_index >= last_param_update_eval_bar + param_update_frequency
    // Decision Making: Adopt candidate if it's better and has enough samples
    if score_samples_candidate >= min_samples_for_decision and candidate_params_score > current_params_score
        learned_length := candidate_length
        learned_bars := candidate_bars
        current_params_score := candidate_params_score
        score_samples_current := score_samples_candidate
        // Optional: runtime.log("RL: Adopted new parameters. L:" + str.tostring(learned_length) + ", B:" + str.tostring(learned_bars) + ", Score:" + str.tostring(current_params_score))

    // Generate New Candidate Parameters
    base_l = learned_length
    base_b = learned_bars
    new_cand_l = base_l
    new_cand_b = base_b

    if math.random(0.0, 1.0) < exploration_chance // Explore: Randomly pick one of 4 directions
        action = math.floor(math.random(0, 4)) // Generates 0, 1, 2, or 3
        if action == 0
            new_cand_l := base_l + length_step
        else if action == 1
            new_cand_l := base_l - length_step
        else if action == 2
            new_cand_b := base_b + bars_step
        else if action == 3 // action == 3
            new_cand_b := base_b - bars_step
    else // Exploit: Small perturbation of current best learned parameters
        action_axis = math.floor(math.random(0, 2)) // 0 for length, 1 for bars
        change_multiplier = math.floor(math.random(-1, 2)) // -1, 0, or 1 (integer)
        
        if action_axis == 0
            new_cand_l := base_l + change_multiplier * float(length_step) // ensure float operation
        else
            new_cand_b := base_b + change_multiplier * float(bars_step)   // ensure float operation
            
    // Clamp new candidate parameters to defined min/max ranges
    candidate_length := math.max(float(length_min), math.min(float(length_max), new_cand_l))
    candidate_bars := math.max(float(bars_min), math.min(float(bars_max), new_cand_b))

    // Reset Scores for New Candidate
    // If the new candidate is identical to the currently learned parameters (e.g. clamping resulted in no change, or exploitation resulted in 0 change)
    // then its score should be the same as the learned parameters' score.
    // Otherwise, it's a genuinely new parameter set and its score starts from 0.
    if candidate_length == learned_length and candidate_bars == learned_bars
        candidate_params_score := current_params_score
        score_samples_candidate := score_samples_current
    else
        candidate_params_score := 0.0 
        score_samples_candidate := 0
    
    // Clear signal tracking arrays for the new evaluation period
    array.clear(signal_bar_indices)
    array.clear(signal_types)
    array.clear(signal_prices)

    // Update the last evaluation bar index
    last_param_update_eval_bar := bar_index

// --- RL: Debug Output ---
if enable_rl and show_rl_debug_info
    plot(learned_length, title="Learned Length", color=color.new(color.blue, 50), style=plot.style_line, display=display.data_window)
    plot(learned_bars, title="Learned Bars", color=color.new(color.purple, 50), style=plot.style_line, display=display.data_window)
    plot(current_params_score, title="Current Params Score", color=color.new(color.green, 50), style=plot.style_line, display=display.data_window)
    plot(candidate_params_score, title="Candidate Params Score", color=color.new(color.orange, 50), style=plot.style_line, display=display.data_window)

//Out Bar 
highlel = Lelex == -1 ? high : na
lowlel = Lelex == 1 ? low : na

//Out level
resistance = float(na)
support = float(na)
resistance := close < open and Lelex ? high : resistance[1]
support := close > open and Lelex ? low : support[1]

//Color 
rescol = color.new(#ff0000, 1)
highcol = ta.change(resistance) == 0 ? rescol : na
supcol = color.new(#138484, 1)
lowcol = ta.change(support) == 0 ? supcol : na

//Plot Bar
plotshape(exhaustionSwitch ? lowlel : na, title='Up', color=color.new(#00ff00, 1), location=location.belowbar, style=shape.triangleup, size=size.normal)
plotshape(exhaustionSwitch ? highlel : na, title='Down', color=color.new(#ff0000, 1), location=location.abovebar, style=shape.triangledown, size=size.normal)

//Plot level
plot(levelSwitch ? resistance : na, title='Reistance Level', style=plot.style_line, color=highcol, linewidth=thicknesSwitch)
plot(levelSwitch ? support : na, title='Support Level', style=plot.style_line, color=lowcol, linewidth=thicknesSwitch)

alertcondition(lowlel, 'Up')
alertcondition(highlel, 'Down')
